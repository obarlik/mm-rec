#include "mm_rec/utils/dashboard_manager.h"
#include "embedded_assets.h"  // Generated by CMake
#include "mm_rec/utils/logger.h"
#include "mm_rec/utils/ui.h"
#include "mm_rec/utils/run_manager.h"
#include "mm_rec/core/vulkan_backend.h"
#include "mm_rec/core/dynamic_balancer.h"
#include "mm_rec/utils/metrics.h"
#include <sstream>
#include <iostream>

namespace mm_rec {

DashboardManager& DashboardManager::instance() {
    static DashboardManager instance;
    return instance;
}

DashboardManager::DashboardManager() {
    // Initialize standard/safe values
    // File opening deferred to set_log_path or lazy init
}

void DashboardManager::set_history_path(const std::string& path) {
    std::lock_guard<std::mutex> lock(history_mtx_);
    if (history_file_.is_open()) {
        history_file_.close();
    }
    history_file_.open(path, std::ios::app);
}

DashboardManager::~DashboardManager() {
    if (history_file_.is_open()) history_file_.close();
    stop();
}

bool DashboardManager::start(const net::HttpServerConfig& base_config) {
    if (server_) return true; // Already running

    int max_retries = 10;
    bool success = false;

    for (int i = 0; i < max_retries; ++i) {
        // Create a copy of config for this attempt
        net::HttpServerConfig current_config = base_config;
        current_config.port = base_config.port + i;
        
        try {
            server_ = std::make_unique<mm_rec::net::HttpServer>(current_config);
            register_routes();
            
            if (server_->start()) {
                std::string msg = "Global Dashboard started on port " + std::to_string(current_config.port);
                LOG_INFO(msg);
                mm_rec::ui::success(msg);
                
                if (current_config.port != base_config.port) {
                    std::string fallback_msg = "(Port " + std::to_string(base_config.port) + " was busy)";
                    LOG_INFO(fallback_msg);
                    mm_rec::ui::warning(fallback_msg);
                }
                success = true;
                break;
            }
        } catch (...) {
            server_.reset();
        }
        
        // Failed, try next
        server_.reset(); 
    }

    if (!success) {
        LOG_ERROR("Failed to start Global Dashboard on any port " + 
                 std::to_string(base_config.port) + "-" + std::to_string(base_config.port + max_retries - 1));
    }
    return success;
}

void DashboardManager::stop() {
    if (server_) {
        server_->stop();
        server_.reset();
        LOG_INFO("Global Dashboard stopped.");
    }
}

void DashboardManager::update_training_stats(float loss, float lr, float speed, int step) {
    stats_.current_loss = loss;
    stats_.current_lr = lr;
    stats_.current_speed = speed;
    stats_.current_step = step;
    
    std::lock_guard<std::mutex> lock(history_mtx_);
    loss_history_.push_back(loss);
    if (loss_history_.size() > max_history_size_) {
        loss_history_.pop_front();
    }
    
    // Persist to CSV: DISABLED (Use binary format + parser)
    // if (history_file_.is_open()) { ... }
    
    // Log directly to High-Efficiency Binary format
    // Value1: Ratio, Value2: Diff
    float ratio = mm_rec::DynamicBalancer::get_gpu_ratio();
    double diff = mm_rec::DynamicBalancer::get_sync_diff();
    
    // Log Training Stats to Metrics
    mm_rec::MetricsManager::record(mm_rec::MetricType::TRAINING_STEP, loss, lr, step, "STEP");
    
    // Log Hybrid Stats
    mm_rec::MetricsManager::record(
        mm_rec::MetricType::HYBRID_PERF, 
        ratio, 
        static_cast<float>(diff), 
        0, 
        "HYBRID"
    );
}

void DashboardManager::update_system_stats(size_t mem_mb) {
    stats_.memory_usage_mb = mem_mb;
}

void DashboardManager::register_routes() {
    if (!server_) return;

    // Home - Serve main HTML
    server_->register_handler("/", [](const std::string&) -> std::string {
        return mm_rec::net::HttpServer::build_response(200, "text/html", assets::INDEX_HTML);
    });

    // Static CSS
    server_->register_handler("/static/style.css", [](const std::string&) -> std::string {
        return mm_rec::net::HttpServer::build_response(200, "text/css", assets::STYLE_CSS);
    });

    // Static JS
    server_->register_handler("/static/app.js", [](const std::string&) -> std::string {
        return mm_rec::net::HttpServer::build_response(200, "application/javascript", assets::APP_JS);
    });
    // API Stats
    server_->register_handler("/api/stats", [this](const std::string&) -> std::string {
        std::stringstream ss;
        ss << "{";
        ss << "\"loss\": " << stats_.current_loss.load() << ",";
        ss << "\"step\": " << stats_.current_step.load() << ",";
        ss << "\"total_steps\": " << stats_.total_steps.load() << ",";
        ss << "\"lr\": " << stats_.current_lr.load() << ",";
        ss << "\"speed\": " << stats_.current_speed.load() << ","; // Original line
        ss << "\"mem\": " << stats_.memory_usage_mb.load() << ","; // Original line
        
        // Hybrid Metrics
        float ratio = mm_rec::DynamicBalancer::get_gpu_ratio();
        double diff = mm_rec::DynamicBalancer::get_sync_diff();
        ss << "\"gpu_ratio\": " << ratio << ",";
        ss << "\"sync_delta\": " << diff << ",";
        
        ss << "\"epoch\": 1,"; // simplified
        
        std::lock_guard<std::mutex> lock(history_mtx_);
        ss << "\"history\": [";
        for(size_t i=0; i<loss_history_.size(); ++i) {
            ss << loss_history_[i] << (i < loss_history_.size()-1 ? "," : "");
        }
        ss << "],";
        ss << "\"avg_history\": []";
        ss << "}";
        return mm_rec::net::HttpServer::build_response(200, "application/json", ss.str());
    });
    
    // API Hardware (Real)
    server_->register_handler("/api/hardware", [](const std::string&) -> std::string {
        auto& vk = mm_rec::VulkanBackend::get();
        std::string gpu_name = vk.is_ready() ? vk.get_device_name() : "Vulkan Not Ready";
        size_t vram_mb = vk.is_ready() ? (vk.get_total_vram() / 1024 / 1024) : 0;
        
        std::stringstream json;
        json << "{";
        json << "  \"cpu_model\": \"Host Processor\","; 
        json << "  \"compute_device\": \"" << gpu_name << "\",";
        json << "  \"mem_total_mb\": " << vram_mb << ","; 
        json << "  \"arch\": \"x86_64 / SPIR-V\",";
        json << "  \"cores_logical\": \"N/A\","; 
        json << "  \"simd\": \"AVX2 / Int8\"";
        json << "}";
        return mm_rec::net::HttpServer::build_response(200, "application/json", json.str());
    });
    
    // Stop Signal
    server_->register_handler("/api/stop", [this](const std::string&) -> std::string {
        stats_.should_stop = true;
        LOG_INFO("Stop signal received from Dashboard.");
        return mm_rec::net::HttpServer::build_response(200, "text/plain", "Stopping...");
    });

    // History API
    server_->register_handler("/api/history", [](const std::string&) -> std::string {
        std::ifstream f("dashboard_history.csv");
        std::vector<float> losses;
        std::string line;
        while (std::getline(f, line)) {
            if (line.empty()) continue;
            std::stringstream ss(line);
            std::string segment;
            std::vector<std::string> seglist;
            while(std::getline(ss, segment, ',')) {
               seglist.push_back(segment);
            }
            if (seglist.size() >= 2) {
                try {
                    losses.push_back(std::stof(seglist[1])); // Loss is 2nd column
                } catch (...) {}
            }
        }
        
        std::stringstream json;
        json << "{ \"loss_history\": [";
        for (size_t i = 0; i < losses.size(); ++i) {
             json << losses[i] << (i < losses.size() - 1 ? "," : "");
        }
        json << "] }";
        
        return mm_rec::net::HttpServer::build_response(200, "application/json", json.str());
    });
    
    // API Runs List
    server_->register_handler("/api/runs", [](const std::string&) -> std::string {
        auto runs = RunManager::list_runs();
        std::stringstream ss;
        ss << "[";
        for (size_t i = 0; i < runs.size(); ++i) {
            const auto& run = runs[i];
            ss << "{";
            ss << "\"name\": \"" << run.name << "\",";
            ss << "\"status\": \"" << run.status_str << "\",";
            ss << "\"epoch\": " << run.current_epoch << ",";
            ss << "\"loss\": " << run.current_loss << ",";
            ss << "\"best_loss\": " << run.best_loss << ",";
            ss << "\"size_mb\": " << run.total_size_mb;
            ss << "}";
            if (i < runs.size() - 1) ss << ",";
        }
        ss << "]";
        return mm_rec::net::HttpServer::build_response(200, "application/json", ss.str());
    });
}

} // namespace mm_rec
